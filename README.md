## Отчёт по лабораторной работе 1: RISC-V

### 1. Постановка задачи

Необходимо реализовать алгоритм на архитектуре RISC-V для вычисления **суммы всех элементов двумерного массива размером N = 3, M = 5** целых чисел.

В работе используется прямоугольный массив \(3 \times 5\):

\[
\begin{bmatrix}
1 & 2 & 3 & 4 & 5 \\
6 & 7 & 8 & 9 & 10 \\
11 & 12 & 13 & 14 & 15
\end{bmatrix}
\]

Все элементы суммируются:

\[
1 + 2 + \dots + 15 = 120
\]

Ожидаемый результат работы программы: **120**.

Требования лабораторной:

- Реализовать алгоритм на языке C.
- Скомпилировать C-код под архитектуру RISC-V с флагами `-march=rv32i -mabi=ilp32`.
- Получить dump-файл (дизассемблированный код) из скомпилированного ELF-файла.
- Реализовать тот же алгоритм на ассемблере RISC-V.
- Отладить и запустить ассемблерную программу в симуляторе Venus (расширение для VS Code), убедиться, что результат равен 120, и оформить отчёт.

---

### 2. Используемое окружение

- ОС: Windows 10.
- Терминал: **MSYS2 UCRT64**.
- IDE/редактор: **Visual Studio Code**.
- Симулятор RISC-V: **Venus** (расширение для VS Code).
- Компилятор C → RISC-V: `riscv64-unknown-elf-gcc` (доступен в окружении UCRT64).

Проверка доступности компилятора выполнялась командой:

which riscv64-unknown-elf-gcc

---

### 3. Реализация на языке C

#### 3.1 Файл `algo.c`

```c
#define N 3
#define M 5

int sum_array(int arr[N][M]) {
    int sum = 0;
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            sum += arr[i][j];  // суммируем все элементы массива
        }
    }
    return sum;
}

int main(void) {
    int arr[N][M] = {
        {  1,  2,  3,  4,  5 },
        {  6,  7,  8,  9, 10 },
        { 11, 12, 13, 14, 15 }
    };

    int result = sum_array(arr);
    return result;  // код возврата программы равен 120
}

```
---

#### Комментарии:

N и M задают размер массива 
3
×
5
3×5.

sum_array проходит по всем элементам массива (двойной цикл по i и j) и накапливает сумму.

main инициализирует массив значениями 1..15, вызывает функцию и возвращает сумму как код завершения (печать через printf не используется).

#### 3.2 Компиляция C-кода под RISC-V

В каталоге проекта lab-riscv-asm-mert выполняются команды:

riscv64-unknown-elf-gcc -march=rv32i -mabi=ilp32 algo.c -o algo.elf

Пояснения:

-march=rv32i — целевая архитектура (базовый набор инструкций RISC-V 32-бит).

-mabi=ilp32 — ABI: типы int, long и указатели имеют размер 32 бита.

Результат — исполняемый ELF-файл algo.elf для RISC-V.

#### 3.3 Получение dump-файла
Для получения дампа используется objdump:


riscv64-unknown-elf-objdump -D -S algo.elf > algo.dump

-D — дизассемблировать все секции.

-S — показывать дизассемблированный код вместе с исходным C-кодом (если есть debug-информация).

Файл algo.dump добавляется в репозиторий.

4. Программа на ассемблере RISC-V
4.1 Общее описание
Ассемблерная программа реализует ту же задачу: сумма всех элементов массива 3×5.

Для упрощения адресации массив хранится в .data как линейный массив из 15 слов (.word), логически соответствующий матрице 
3
×
5
3×5.
Цикл в .text последовательно обрабатывает элементы с индексом 0..14.
Итоговая сумма сохраняется в регистре t2.

4.2 Код algo.s
    .data
array:
    .word  1,  2,  3,  4,  5
    .word  6,  7,  8,  9, 10
    .word 11, 12, 13, 14, 15   # всего 15 элементов

    .text
    .globl main
main:
    la   t0, array     # t0 = базовый адрес массива
    li   t1, 0         # t1 = i (индекс элемента, 0..14)
    li   t2, 0         # t2 = sum (накопленная сумма)

loop:
    li   t3, 15        # общее количество элементов = 15
    bge  t1, t3, end   # если i >= 15, выходим из цикла

    slli t4, t1, 2     # t4 = i * 4 (смещение в байтах, word = 4 байта)
    add  a0, t0, t4    # a0 = адрес array[i]
    lw   a1, 0(a0)     # a1 = array[i]
    add  t2, t2, a1    # sum += array[i]

    addi t1, t1, 1     # i++
    j    loop          # следующая итерация

end:
    nop                # в этот момент t2 = 120 (0x00000078)

Ключевые моменты:

Массив задан как 15 слов, но логически это матрица 3×5.

Индекс t1 пробегает все элементы от 0 до 14.

Смещение вычисляется как i * 4, так как один элемент занимает 4 байта.

Итоговая сумма находится в t2 и должна равняться 120 (0x00000078).

5. Отладка в симуляторе Venus (VS Code)
Открыт каталог lab-riscv-asm-mert в VS Code, файл algo.s открыт в редакторе.

В правом нижнем углу выбран язык RISC-V Assembly, чтобы активировать расширение Venus.

Изображение №1: скриншот VS Code с открытым algo.s и выбранным языком RISC-V Assembly
(файл 1.png в репозитории).

Через Command Palette (Ctrl+Shift+P) запущен симулятор Venus (Run/Debug).

Программа выполняется до метки end:.

Изображение №2: скриншот окна Venus во время выполнения программы
(файл 2.png).

Установлен breakpoint в конце программы (на метке end: / строке nop), после выполнения цикла проверено значение регистра t2.

Ожидаемое значение: t2 = 0x00000078 (120).

Изображение №3: скриншот панели регистров, где t2 = 0x00000078
(файл 3.png).

6. Структура репозитория
Итоговое содержимое каталога lab-riscv-asm-mert:

algo.c — реализация алгоритма на C (сумма элементов массива 3×5).

algo.s — реализация алгоритма на ассемблере RISC-V.

algo.elf — исполняемый файл для архитектуры RISC-V.

algo.dump — дамп дизассемблированного кода.

README.md — данный отчёт.

(опционально) файлы скриншотов 1.png, 2.png, 3.png, используемые в отчёте.

7. Замечания по настройке тулчейна
Для выполнения работы использовался MSYS2 UCRT64 под Windows и пакет riscv64-unknown-elf-gcc, установленный через менеджер пакетов MSYS2.

Все команды компиляции и получения дампа выполнялись в терминале UCRT64 в каталоге:

/c/Users/Mert/lab-riscv-asm-mert

Использованные команды:

riscv64-unknown-elf-gcc -march=rv32i -mabi=ilp32 algo.c -o algo.elf
riscv64-unknown-elf-objdump -D -S algo.elf > algo.dump

После этого файлы algo.elf и algo.dump добавлены в репозиторий и используются в отчёте, что соответствует требованиям задания для варианта 6.
